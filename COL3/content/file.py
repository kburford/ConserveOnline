# COL3
# Copyright(C), 2007, Enfold Systems, Inc. - ALL RIGHTS RESERVED
#
# This software is licensed under the Terms and Conditions
# contained within the "license.txt" file that accompanied
# this software.  Any inquiries concerning the scope or
# enforceability of the license should be addressed to:
#
#
# Enfold Systems, Inc.
# 4617 Montrose Blvd., Suite C215
# Houston, Texas 77006 USA
# p. +1 713.942.2377 | f. +1 832.201.8856
# www.enfoldsystems.com
# info@enfoldsystems.com

import os.path
from tempfile import mkdtemp
from cStringIO import StringIO
from ZODB.POSException import ConflictError
import PIL

from zope.interface import implements
from zope.component import adapts #@UnresolvedImport
from AccessControl.SecurityInfo import ClassSecurityInfo

from plone.app.blob.interfaces import IBlobbable
from plone.app.blob.utils import guessMimetype
from plone.app.blob.field import BlobMarshaller, BlobWrapper
from plone.app.blob.content import ATBlob, ATBlobSchema

from Products.ATContentTypes.content.schemata import finalizeATCTSchema
from Products.Archetypes.public import Schema, StringField, registerType
from Products.Archetypes.public import LinesField, ReferenceField
from Products.Archetypes.public import FileField
from Products.Archetypes.Field import Image
from Products.Archetypes.debug import log_exc

from Products.COL3.content.base import IsPrivateMixin
from Products.COL3.content.label import LabelledMixin
from Products.COL3.interfaces.file import IFile
from Products.COL3.content.base import Taxonomy
from Products.COL3 import config

try:
    from os import link
except ImportError:
    # best we can do on windows for now...
    from shutil import copyfile as link

THUMBNAIL_TYPES = set(config.THUMBNAIL_TYPES)
PIL_RESIZE_ALGO = PIL.Image.ANTIALIAS
PIL_QUALITY = 88

def scale(original_file, w=128, h=128, default_format='PNG'):
    """ scale image (Taken from Archetype's ImageField)"""
    size = w, h

    image = PIL.Image.open(original_file)
    # consider image mode when scaling
    # source images can be mode '1','L,','P','RGB(A)'
    # convert to greyscale or RGBA before scaling
    # preserve palletted mode (but not pallette)
    # for palletted-only image formats, e.g. GIF
    # PNG compression is OK for RGBA thumbnails
    original_mode = image.mode
    if original_mode == '1':
        image = image.convert('L')
    elif original_mode == 'P':
        image = image.convert('RGBA')
    image.thumbnail(size, PIL_RESIZE_ALGO)
    format = image.format and image.format or default_format
    # decided to only preserve palletted mode
    # for GIF, could also use image.format in ('GIF','PNG')
    if original_mode == 'P' and format == 'GIF':
        image = image.convert('P')
    thumbnail_file = StringIO()
    # quality parameter doesn't affect lossless formats
    image.save(thumbnail_file, format, quality=PIL_QUALITY)
    thumbnail_file.seek(0)
    return thumbnail_file, format.lower()

def addCOLFile(self, id, title='', description=''):
    """ Create a new File
    """
    wg = COLFile(id, title=title, description=description)
    self._setObject(id, wg)

class COLFile(ATBlob, IsPrivateMixin, LabelledMixin, Taxonomy):
    """ is a File that participates in Labelling
    """
    implements(IFile)
    meta_type = portal_type = archetype_name = 'COLFile'
    security = ClassSecurityInfo()

    schema = (ATBlobSchema.copy() + #@UndefinedVariable
              Taxonomy.schema.copy() + #@UndefinedVariable
              IsPrivateMixin.schema.copy() + #@UndefinedVariable
              LabelledMixin.schema.copy() + #@UndefinedVariable
              Schema((LinesField('document_type'),
                      LinesField('authors'),
                      ReferenceField('libraryreference',
                                     relationship='IsAlsoInLibrary'),
                      StringField('license'),
                      FileField('gisdata')
                      ))
              )
    schema['title'].required = False
    finalizeATCTSchema(schema, folderish=False, moveDiscussion=False)
    schema.registerLayer('marshall', BlobMarshaller())

    def _isIDAutoGenerated(self, id):
        """ Block renaming on setting the file field and set the
        thumbnail if possible
        """
        # new file, delete old thumbnail if it exists
        if getattr(self, 'image_thumb', None) is not None:
            del self.image_thumb

        if (self.getContentType() in THUMBNAIL_TYPES and
            not self.generateThumbnail()):
            # came in as a web image, but we couldn't resize it
            # force a downloadable mime type so as not to break
            # browsers and not to be selected for thumbnails.
            self.setContentType('application/octet-stream')
        
        # block renaming
        return False

    def generateThumbnail(self):
        """Creates self.img_thumb if image is resizable
        
        Bastardized from Archetypes.atapi.ImageField.createScales()"""
        __traceback_info__ = ('generating thumbnail', self)
        try:
          try:
            datastream = self.getFile().getBlob().open('r')
            imgdata, format = scale(datastream)
          except (ConflictError, KeyboardInterrupt):
            raise
          except:
            log_exc()
            # scaling failed, don't create a scaled version
            return False
        finally:
            datastream.close()

        mimetype = 'image/%s' % format.lower()
        image = Image('image_thumb', title=self.Title(), file=imgdata,
                      content_type=mimetype)
        image.filename = self.getFilename()
        try:
            delattr(image, 'title')
        except (KeyError, AttributeError):
            pass
        self.image_thumb = image
        # thumbnail generated correctly
        return True

registerType(COLFile)

class TempLinkFeeder(object):

    implements(IBlobbable)

    def __init__(self, context):
        self.context = context

    def _getFSPath(self):
        raise NotImplementedError('implement on subclasses')

    def feed(self, blob):
        """ see interface ... """
        # this works on O(1) if the file is in the same filesystem
        # as the blob storage, and we're on unix
        orig_path = self._getFSPath()
        assert os.path.isfile(orig_path)
        link_dir = mkdtemp(dir=os.path.dirname(orig_path))
        link_path = os.path.join(link_dir, 'consume')
        link(orig_path, link_path)
        blob.consumeFile(link_path)
        os.rmdir(link_dir)
        # being paranoid:
        assert os.path.isfile(orig_path)

class BlobbableStandardFile(TempLinkFeeder):
    """ adapter for standard file objects to work with blobs """

    adapts(file)

    def _getFSPath(self):
        return self.context.name

    def filename(self):
        """ see interface ... """
        return self._getFSPath()

    def mimetype(self):
        """ see interface ... """
        return guessMimetype(self.context, self.filename())

class BlobbableBlobWrapper(TempLinkFeeder):
    """ adapter for BlobWrapper objects to work with blobs """

    adapts(BlobWrapper)

    def _getFSPath(self):
        orig_path = self.context.getBlob()._current_filename()
        return orig_path

    def filename(self):
        """ see interface ... """
        return self.context.getFilename()

    def mimetype(self):
        """ see interface ... """
        return self.context.getContentType()
